cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c     Copyright c 1990 The Board of Trustees of the Leland Stanford
c     Junior University. All rights reserved.  This routine may not
c     be used without the prior written consent of Stanford University.
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c Wed Feb 28 14:16:47 PST 1990 (anderson--stanford)
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c 
      SUBROUTINE VMNPD(ineq,a,l,u,di,x,
     +                 ja,jl,ju,ia,il,iu,iva,ivl,ivu,ipc,ipri)
      include 'p2conf.h'
c 
c*******************************************************************
c*                                                                 *
c*        v m n p  - sparse lu factorization (numeric)             *
c*                                                                 *
c*                         (double)                                *
c*                                                                 *
c*******************************************************************
c*                                                                 *
c*      This subroutine performs the numeric lu factorization      *
c*      a general non-singular sparse matrix.  it operates on      *
c*       descriptions of these matrices generated by vmsp.         *
c*                                                                 *
c*         ***** arbitrary pivoting order version *****            *
c
c     Original : C.H.Price    Stanford University       May, 1982
c     Revision : MRP          Stanford University       Nov, 1983
c
c     Copyright c 1981 The board of trustees of the Leland Stanford 
c                      Junior University.  All rights reserved.
c     This subroutine may not be used outside of the PISCES computer
c     program without the prior written consent of Stanford University. 
c 
c*                                                                 *
c*******************************************************************
c
c  ipc   - column pivot permutation vector
c  ipri  - inverse row pivot permutation vector 
c 
c 
c  n     - number of columns in the matrix. 
c 
c 
c  ja(j) - start of column position descriptors in ia for column j. 
c  ia    - if negative, iabs is starting row of a single element. 
c        - if positive, sharting coulmn for a vector , and the
c          next element of ia is ending row for this vector.
c  iva   - pointer to first column j a matrix value (in a.) 
c  a     - above group of arrays describe info in this array. 
c 
c 
c  ju(j) - start of row position descriptors in iu for col j
c  jl(j) - start of row position descriptors in il for col j
c  iu    - if negative, iabs is row index of single element.
c        - if positive, starting row for a vector, and the
c          next element of iu is ending row for this vector.
c  il    - if negative, iabs is row index of single element.
c        - if positive, starting row for a vector, and the
c          next element of il is ending row for this vector.
c  ivu   - index of first column j u matrix value.
c  ivl   - index of first column j l matrix value.
c 
c 
c  u     - vector of upper triangular numerical values. 
c  l     - vector of lower triangular numerical values. 
c 
c 
c  di    - vector of inverse diagonal element values
c  x     - work vector of length n. 
c 
c*************************************************************
c 
c  stop 27201 - numerical value of pivot is approximately 0.
c 
c*************************************************************
c 
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c 
c                   common area 
c 
      include     'blank.h'
c
c****************************************************************** 
c 
c                   type declarations 
c 
      integer iuu,ill,jlbot,jabot,jubot,i,j,n,jutop,jltop,jatop,
     +        k,iaa,iap,ial,iuj,iujl,ll,ibot,ill2m,ilk,ilkl,idiff,
     +        itop,ii,ilj,iljl,ineq
      integer ja(1),jl(1),ju(1),iva(1),ivl(1),ivu(1)
      INTeger   ia(1),il(1),iu(1),ipc(1),ipri(1)
      double precision xji,xd,l(1),u(1),di(1),x(1),a(1)
c 
c****************************************************************** 
c 
c                   start 
c 
c initialize pointers:
c   iuu is index into l matrix value vector.
c     (used to store values in l and u calculation loops.)
c   iaa is index into a matrix value vector.
c     (used to retrieve values from a matrix for each column.)
c 
      n=ineq 
      iuu= 0
      ill= 0
      jlbot= 0
      jabot= 0
      jubot= 0
      do 17 i=1,n 
17    x(i)=0.d0
c*****
c loop to calculate numerical values for column j of l and u
c*****
      do 80 j= 1,n
c 
c get pointers for this column in l and u:
c   jutop is index to top of row descriptors for this column in u.
c   jubot is index of bottom of row descriptors for this column in u. 
c   jltop is index to top of row descriptors for this column in l.
c   jlbot is index to bottom of row descriptors for this column in l. 
         jutop= jubot+1 
         jubot= ju(j+1)-1 
         jltop= jlbot+1 
         jlbot= jl(j+1)-1 
c 
c get pointer to data value descriptors for a:
c   jatop is index to top of row indicies for this column.
c   jabot is index to bottom of row indicies for this column. 
c 
c   *** note ***  we are processing column ipc(j) of a ***
c 
         jatop= ja(ipc(j))
         jabot= ja(ipc(j)+1)-1
c 
c initialize workspace x with zeros at resultant positions
c 
c ***** could approximate - zero lowest to highest position 
c 
c if there are no nonzero positions in l then the only resultant
c positions will be the elements in l.  since these will be given 
c initial values in the loop beginning at #31 below, we dont need 
c to zero any positions in this case. 
c        if (jutop.gt.jubot) goto 30
c zeros in x at positions of columns of iu
c        k= jutop 
c10         iui= iu(k)
c           if(iui.lt.0) goto 12
c           k= k+1
c           iue= iu(k)
c           do 11 i= iui,iue
c11            x(i)= 0.d0
c           goto 13 
c12         x(-iui)= 0.d0
c13         k= k+1
c           if (k.le.jubot) goto 10 
c zeros in x at positions of columns of il
c        if (jltop.gt.jlbot) goto 30
c        k= jltop 
c20         ili= il(k)
c           if(ili.lt.0) goto 22
c           k= k+1
c           ile= il(k)
c           do 21 i= ili,ile
c21            x(i)= 0.d0
c           goto 23 
c22         x(-ili)= 0.d0
c23         k= k+1
c           if (k.le.jlbot) goto 20 
c copy column ipc(j) of a into x
c 30      continue 
         iaa= iva(ipc(j))-1 
         k= jatop 
 31         iap= ia(k)
            if (iap.lt.0) goto 33 
            k= k+1
            ial=ia(k)-iap+1 
            do 32 i= 1,ial
 32            x(ipri(iap+i-1))= a(iaa+i) 
            iaa= iaa+ial
            goto 34 
 33         iaa= iaa+1
            x(ipri(-iap))= a(iaa) 
 34         k= k+1
            if (k.le.jabot) goto 31 
c 
c********** 
c     calculate entries in column j of upper triangular matrix u
c********** 
c 
c nothing to do if column j of u contains only the diagonal element 
         if (jutop.gt.jubot) goto 60
c loop on each descriptor in iu matrix for this column in u.
         i= jutop 
 40         iuj= iu(i)
c get next element from column j
            if (iuj.gt.0) goto 41 
            iuj= -iuj 
            iujl= iuj 
            goto 42 
 41         i= i+1
            iujl= iu(i) 
c loop on each position in the element
 42         do 54 ll= iuj,iujl
               xji= x(ll) 
               x(ll)=0.d0
               u(iuu+ll-iuj+1)= xji
c locate row descriptor indicies for column ll in u 
               itop= jl(ll) 
               ibot= jl(ll+1)-1 
               if (itop.gt.ibot) goto 54
c column has symbolic positions so loop through them
               ill2m= ivl(ll)-1 
               k= itop
 50               ilk=il(k) 
c operate on an element from column ll
                  if (ilk.lt.0) goto 52 
c vector in column ll 
                  k= k+1
                  ilkl= il(k) 
                  idiff=ill2m-ilk+1 
                  do 51 ii= ilk,ilkl
                       x(ii)=x(ii)-xji*l(idiff+ii)
51                  continue
c update value index to point to above next value in l. 
                  ill2m= idiff+ilkl 
                  goto 53 
c scalar in column ll 
 52               ill2m= ill2m+1
                     x(-ilk)= x(-ilk)-xji*l(ill2m)
 53               k= k+1
                  if (k.le.ibot) goto 50
 54            continue 
c done with this element/vector in the a matrix.
c update iuu to point to next value to be stored. 
            iuu= iuu+iujl-iuj+1 
            i= i+1
            if (i.le.jubot) goto 40 
c 
c********** end of computation of column j of l **********
c 
c set and store reciprocal of diagonal element l(jj)
c 
 60      xd= x(j) 
      x(j)=0.d0
         if (dabs(xd).eq.0.d0) goto 90
         xd= 1.d0/xd
         di(j)= xd
c********** 
c     calculate entries in column j of upper triangular matrix l
c********** 
c 
c branch if column j of l contains only the diagonal element l(j)=1 
         if (jltop.gt.jlbot) goto 80
c loop on each descriptor in iu matrix for this column in l.
         i= jltop 
 70         ilj= il(i)
c get element from column j 
            if (ilj.lt.0) goto 72 
            i= i+1
            iljl= il(i) 
c operate on a vector 
            do 71 ii=ilj,iljl 
                  l(ill+ii-ilj+1)= xd*x(ii)
71             x(ii)=0.d0
            ill= ill+iljl-ilj+1 
            goto 73 
c operate on a scalar 
 72         ill= ill+1
               l(ill)= xd*x(-ilj)
      x(-ilj)=0.d0
 73         i= i+1
            if (i.le.jlbot) goto 70 
c********** end of computation of column j of l **********
 80      continue 
      return
c                   pivot is approx. zero 
 90   call erset(61,linum,j)
      return
      end 
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c 
      SUBROUTINE VMBPCD(neq,l,u,rhs,di,x,soln,
     +                  jl,ju,il,iu,ivl,ivu,ipc,ipri)
      include 'p2conf.h'
c 
c*******************************************************************
c*                                                                 *
c*         v m b p c - sparse forward and back substitution        *
c*                                                                 *
c*******************************************************************
c*                                                                 *
c*    This subroutine solves the matrix equation a*x=b given       *
c*    the column ordered lu factored a matrix (from vmnp) and      *
c*    the vector b.                                                *
c*                                                                 *
c*         ***** arbitrary pivoting order version *****            *
c
c     Original : C.H.Price    Stanford University       May, 1982
c     Revision : MRP          Stanford University       Nov, 1983
c 
c     Copyright c 1981 The board of trustees of the Leland Stanford 
c                      Junior University.  All rights reserved.
c     This subroutine may not be used outside of the PISCES computer
c     program without the prior written consent of Stanford University. 
c 
c*                                                                 *
c*******************************************************************
c 
c  n     - number of columns in the matrix. 
c 
c 
c  ju(j) - start of row position descriptors in iu for col j
c  jl(j) - start of row position descriptors in il for col j
c  iu    - if negative, iabs is row index of single element.
c        - if positive, starting row for a vector, and the
c          next element of iu is ending row for this vector.
c  il    - if negative, iabs is row index of single element.
c        - if positive, starting row for a vector, and the
c          next element of il is ending row for this vector.
c  ivu   - index of first column j u matrix value.
c  ivl   - index of first column j l matrix value.
c 
c 
c  u     - vector of upper triangular numerical values. 
c  l     - vector of lower triangular numerical values. 
c  x     - scratch vector of length n.
c  rhs   - vector of right hand side values.
c  soln  - returned solution vector for equation a*x=b (may be rhs)
c  di    - vector of inverse diagonal element values. 
c 
c 
c  ipc   - column pivot permutation vector. 
c  ipri  - inverse row pivot permutation vector.
c 
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c 
c                   type declarations 
c 
      integer n,nm1,i,iprix,jtop,jbot,ivlj,iljl,ilj,idiff,j,ivuj, 
     +        iujl,iuj,k
      integer neq,jl(1),ju(1),ivl(1),ivu(1)
      INTeger   il(1),iu(1),ipc(1),ipri(1)
      double precision alpha,aux,l(1),u(1),rhs(1),di(1),x(1),soln(1)
c 
c****************************************************************** 
c 
c                   start 
c 
      n=neq 
      nm1= n-1
c 
c 
      do 5 i= 1,n 
         iprix= ipri(i) 
 5       x(iprix)= rhs(i) 
c 
c forward substitution
c 
      do 30 j=1,nm1 
         jtop= jl(j)
         jbot= jl(j+1)-1
         ivlj= ivl(j)-1 
         aux= x(j)
         if (jtop.gt.jbot) goto 30
         i= jtop
 10         iljl= il(i) 
            if (iljl.lt.0) goto 20
            i= i+1
            ilj= il(i)
            idiff= ivlj-iljl+1
            do 15 k= iljl,ilj 
                 x(k)= x(k)-aux*l(idiff+k)
15            continue
            ivlj= idiff+ilj 
            goto 25 
 20         ivlj= ivlj+1
                 x(-iljl)= x(-iljl)-aux*l(ivlj)
 25         i= i+1
            if (i.le.jbot) goto 10
 30      continue 
      x(n)= x(n)*di(n)
c 
c back substitution 
c 
      j= n
 32      alpha= x(j)
         jtop= ju(j)
         jbot= ju(j+1)-1
         ivuj= ivu(j)-1 
         if (jtop.gt.jbot) goto 55
         i= jtop
 35         iujl= iu(i) 
            if (iujl.lt.0) goto 45
            i= i+1
            iuj= iu(i)
            idiff= ivuj-iujl+1
            do 40 k= iujl,iuj 
                  x(k)=x(k)-alpha*u(idiff+k)
40             continue
            ivuj= idiff+iuj 
            goto 50 
 45         ivuj= ivuj+1
               x(-iujl)=x(-iujl)-alpha*u(ivuj)
 50         i= i+1
            if (i.le.jbot) goto 35
 55      j= j-1 
         x(j)= x(j)*di(j) 
         if (j.gt.1) goto 32
      do 60 j= 1,n
 60      soln(ipc(j))= x(j)
      return
      end 
